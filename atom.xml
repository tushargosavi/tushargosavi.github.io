<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tushar Gosavi Blogs]]></title>
  <link href="http://blog.tushargosavi.in/atom.xml" rel="self"/>
  <link href="http://blog.tushargosavi.in/"/>
  <updated>2014-06-24T09:24:28+05:30</updated>
  <id>http://blog.tushargosavi.in/</id>
  <author>
    <name><![CDATA[Tushar R. Gosavi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Delete in BST]]></title>
    <link href="http://blog.tushargosavi.in/blog/2014/06/21/delete-in-bst/"/>
    <updated>2014-06-21T12:44:45+05:30</updated>
    <id>http://blog.tushargosavi.in/blog/2014/06/21/delete-in-bst</id>
    <content type="html"><![CDATA[<p>In the <a href="http://blog.tushargosavi.in/blog/2014/06/16/bst-in-haskell/">previous post</a>, we implemented a simple Binary Search Tree(BST) and added functionality to
add/search and traverse binary tree. In this post we will add functionality to remove
keys from BST. Deleting a key in binary tree is little difficult, to delete a node
from tree we need to consider following cases.</p>

<ol>
<li>The Tree is Nil, Then after deleting resulting tree is Nil.</li>
<li>If the Node has matching key and it&rsquo;s left and right children are Nil, then resulting tree is Nil tree.</li>
<li>If nodes right children in Nil

<ul>
<li>If key matches the resulting tree is left tree.</li>
<li>else if node&rsquo;s key is bigger then try deleting search key from left tree</li>
<li>otherwise search key do not exists in tree, tree remains as it is.</li>
</ul>
</li>
<li>Symmetric to case 3, for left children.</li>
<li>If node does not have matching key, and node&rsquo;s key is bigger than search key, then try deleting from left subtree, else try deleting from right subtree.</li>
<li>The complex case is when, Node key is matching and it&rsquo;s right and left subtrees are not Nil, In this case we will pick up maximum key from left subtree and replace it with current node, and delete maximum key from the left tree.</li>
</ol>


<p>The resulting Haskell implementation is below.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">delete</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
</span><span class='line'><span class="c1">-- case 1</span>
</span><span class='line'><span class="nf">delete</span> <span class="kt">Nil</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Nil</span>
</span><span class='line'><span class="c1">-- case 2</span>
</span><span class='line'><span class="nf">delete</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="n">key</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">key</span> <span class="ow">=</span> <span class="kt">Nil</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="kt">Nil</span> <span class="kt">Nil</span>
</span><span class='line'><span class="c1">-- case 3</span>
</span><span class='line'><span class="nf">delete</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="kt">Nil</span> <span class="n">right</span><span class="p">)</span> <span class="n">key</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">key</span>  <span class="ow">=</span> <span class="n">right</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">key</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="kt">Nil</span> <span class="p">(</span><span class="n">delete</span> <span class="n">right</span> <span class="n">key</span><span class="p">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="kt">Nil</span> <span class="n">right</span>
</span><span class='line'><span class="c1">-- case 4</span>
</span><span class='line'><span class="nf">delete</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="kt">Nil</span><span class="p">)</span> <span class="n">key</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">key</span> <span class="ow">=</span> <span class="n">left</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">key</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="n">delete</span> <span class="n">left</span> <span class="n">key</span><span class="p">)</span> <span class="kt">Nil</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="kt">Nil</span>
</span><span class='line'><span class="c1">-- case 5 and 6  </span>
</span><span class='line'><span class="nf">delete</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span> <span class="n">key</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">key</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">maxLeft</span> <span class="p">(</span><span class="n">delete</span> <span class="n">left</span> <span class="n">maxLeft</span><span class="p">)</span> <span class="n">right</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">key</span>  <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="n">delete</span> <span class="n">left</span> <span class="n">key</span><span class="p">)</span> <span class="n">right</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="p">(</span><span class="n">delete</span> <span class="n">right</span> <span class="n">key</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">where</span>
</span><span class='line'>    <span class="n">maxLeft</span> <span class="ow">=</span> <span class="n">maxElemNonNil</span> <span class="n">left</span>
</span><span class='line'>    <span class="n">maxElemNonNil</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="kr">_</span> <span class="kt">Nil</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">maxElemNonNil</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="kr">_</span> <span class="n">left</span><span class="p">)</span> <span class="ow">=</span> <span class="n">maxElemNonNil</span> <span class="n">left</span>
</span></code></pre></td></tr></table></div></figure>


<p>A ghci session to test delete function.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">93</span><span class="p">]</span>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">tree</span> <span class="ow">=</span> <span class="n">list2Tree</span> <span class="n">a</span>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">tree</span>
</span><span class='line'><span class="kt">Node</span> <span class="mi">10</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">2</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">5</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">))</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">13</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">18</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">28</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">27</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">95</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">73</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">49</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">75</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">93</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)))</span> <span class="kt">Nil</span><span class="p">))))</span>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="n">tree</span> <span class="mi">73</span>
</span><span class='line'><span class="kt">Node</span> <span class="mi">10</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">2</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">5</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">))</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">13</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">18</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">28</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">27</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">95</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">49</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">75</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">93</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)))</span> <span class="kt">Nil</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BST in Haskell]]></title>
    <link href="http://blog.tushargosavi.in/blog/2014/06/16/bst-in-haskell/"/>
    <updated>2014-06-16T11:57:33+05:30</updated>
    <id>http://blog.tushargosavi.in/blog/2014/06/16/bst-in-haskell</id>
    <content type="html"><![CDATA[<p>I have just started to learn Haskell from various sources, such as
<a href="http://learnyouahaskell.com/">Lean You Haskell</a> and <a href="http://book.realworldhas">Real World Haskell</a>. After reading
few chapters, this is my first attempt to code a <a href="http://en.wikipedia.org/wiki/Binary_search_tree">Binary Search Tree</a> in
Haskell, supporting add, search and traverse operation.</p>

<p>A node is Binary Search Tree contains a comparable key and left and
right subtrees, which can be empty. The left tree contains
smaller keys and right tree contains bigger keys that the node&rsquo;s key.</p>

<p>The Tree is recursively defined as a Nil tree i.e a empty tree, or a Node with key, left and right subtrees. This recursive
data definition is specified in Haskell easily using abstract data type as follows.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'>      <span class="o">|</span> <span class="kt">Nil</span>
</span><span class='line'>      <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Insert</h2>

<p>To add a key in a BST is easy, if tree is empty, then after adding
one key is equivalent of creating a new Node with left and right tree
set to Nil, and data set to the key.</p>

<p>If new key is smaller than current node&rsquo;s key then add a key to the left
tree, else add the key to right tree.</p>

<p>The following function implements the insert method which takes a Tree
and key to be added to the tree. If key is already present in the Tree
then this function returns the same Tree, else returns a new Tree with
key added. As Haskell is purely functional language, we can not modify
original tree, instead it creates a new tree every time a key is added
to the tree.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="cm">{-</span>
</span><span class='line'><span class="cm">Add a node to Tree, If element already present in the Tree,</span>
</span><span class='line'><span class="cm">then it is ignored.</span>
</span><span class='line'><span class="cm">-}</span>
</span><span class='line'><span class="nf">insert</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
</span><span class='line'><span class="nf">insert</span> <span class="kt">Nil</span> <span class="n">elem</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">elem</span> <span class="kt">Nil</span> <span class="kt">Nil</span>
</span><span class='line'><span class="nf">insert</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">val</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span> <span class="n">elem</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">elem</span> <span class="o">&lt;</span> <span class="n">val</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">val</span> <span class="p">(</span><span class="n">insert</span> <span class="n">left</span> <span class="n">elem</span><span class="p">)</span> <span class="n">right</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">elem</span> <span class="o">&gt;</span> <span class="n">val</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">val</span> <span class="n">left</span> <span class="p">(</span><span class="n">insert</span> <span class="n">right</span> <span class="n">elem</span><span class="p">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">val</span> <span class="n">left</span> <span class="n">right</span>
</span></code></pre></td></tr></table></div></figure>


<p>If we want to add bunch of keys to the Tree, then built in fold
function can be used, A one line function to add list of keys to
the Tree is</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">list2Tree</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="n">insert</span> <span class="kt">Nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&rsquo;s try these functions in ghci session.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">69</span><span class="p">,</span> <span class="mi">85</span><span class="p">]</span>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">tree</span> <span class="ow">=</span> <span class="n">list2Tree</span> <span class="n">a</span>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">tree</span>
</span><span class='line'><span class="kt">Node</span> <span class="mi">30</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">10</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">))</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">45</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">69</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">85</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Inserting a new node</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">tree</span>
</span><span class='line'><span class="kt">Node</span> <span class="mi">30</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">10</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">))</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">45</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">69</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">85</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)))</span>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">newtree</span> <span class="ow">=</span>  <span class="n">insert</span> <span class="n">tree</span> <span class="mi">35</span>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">newtree</span>
</span><span class='line'><span class="kt">Node</span> <span class="mi">30</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">10</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">))</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">45</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">35</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">69</span> <span class="kt">Nil</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">85</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Search</h2>

<p>Searching in binary tree starts at the root node and then recursively
follow left or right branch until we reach at empty tree (Nil) or
search key is found. The function is split into two cases.</p>

<ul>
<li>If current root is Nil then we have reached at the leaf node, and element
does not exists in the tree, so we return false. (line 3)</li>
<li>If current root is not Nil and key matches then element present in the tree,
else we recursively call search with left or right node depending on value of
key. (line 5,6,7)</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="cm">{- Search a tree -}</span>
</span><span class='line'><span class="nf">search</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span><span class='line'><span class="nf">search</span> <span class="kt">Nil</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</span><span class='line'><span class="nf">search</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">elem</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span> <span class="n">a</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">elem</span> <span class="o">&gt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="n">search</span> <span class="n">left</span> <span class="n">a</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">search</span> <span class="n">right</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lets try out search on some of the keys.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">search</span> <span class="n">newtree</span> <span class="mi">85</span>
</span><span class='line'><span class="kt">True</span>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">search</span> <span class="n">newtree</span> <span class="mi">80</span>
</span><span class='line'><span class="kt">False</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Traversing elements in the tree.</h2>

<p>Apart from breath first and depth first traversal, binary tree can be
traverse in pre-order, post-order and in-order traversal. The in-order
traversal visit elements in the sorted order. Following is the
implementation in Haskell which returns a list of element in order
they are visited in the traversal.</p>

<ul>
<li>Pre-order

<ul>
<li>Visit the root.</li>
<li>Traverse the left subtree.</li>
<li>Traverse the right subtree.</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="cm">{- Pr-eorder tree traversal -}</span>
</span><span class='line'><span class="nf">preOrder</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class='line'><span class="nf">preOrder</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">preOrder</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span> <span class="ow">=</span>
</span><span class='line'>  <span class="n">a</span> <span class="kt">:</span> <span class="n">preOrder</span> <span class="n">left</span> <span class="o">++</span> <span class="n">preOrder</span> <span class="n">right</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>In-order (symmetric)

<ul>
<li>Traverse the left subtree.</li>
<li>Visit the root.</li>
<li>Traverse the right subtree.</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="cm">{- In-order tree traversal -}</span>
</span><span class='line'><span class="nf">inOrder</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class='line'><span class="nf">inOrder</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">inOrder</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span> <span class="ow">=</span>
</span><span class='line'>  <span class="n">inOrder</span> <span class="n">left</span> <span class="o">++</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">++</span> <span class="n">inOrder</span> <span class="n">right</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Post-order

<ul>
<li>Traverse the left subtree.</li>
<li>Traverse the right subtree.</li>
<li>Visit the root.</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="cm">{- Post-order tree traversal -}</span>
</span><span class='line'><span class="nf">postOrder</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class='line'><span class="nf">postOrder</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">postOrder</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span> <span class="ow">=</span>
</span><span class='line'>  <span class="n">postOrder</span> <span class="n">left</span> <span class="o">++</span> <span class="n">postOrder</span> <span class="n">right</span> <span class="o">++</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lets try these functions, see that in-order traversal of BST gives
element in sorted order.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">preOrder</span> <span class="n">newtree</span>
</span><span class='line'><span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">69</span><span class="p">,</span><span class="mi">85</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">postOrder</span> <span class="n">newtree</span>
</span><span class='line'><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">85</span><span class="p">,</span><span class="mi">69</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">30</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">inOrder</span> <span class="n">newtree</span>
</span><span class='line'><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">69</span><span class="p">,</span><span class="mi">85</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Find Max and Min</h2>

<p>The maximum element is the right most element in the tree, i.e keep following
right branch until node&rsquo;s right branch is Nil. That node has the maximum value
of the key.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">maxElem</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</span><span class='line'><span class="nf">maxElem</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</span><span class='line'><span class="nf">maxElem</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">elm</span> <span class="kr">_</span> <span class="kt">Nil</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">elm</span>
</span><span class='line'><span class="nf">maxElem</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="kr">_</span> <span class="n">right</span><span class="p">)</span> <span class="ow">=</span> <span class="n">maxElem</span> <span class="n">right</span>
</span></code></pre></td></tr></table></div></figure>


<p>Similarly the minimum element is found by following left branch.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">minElem</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</span><span class='line'><span class="nf">minElem</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</span><span class='line'><span class="nf">minElem</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="kt">Nil</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">a</span>
</span><span class='line'><span class="nf">minElem</span> <span class="p">(</span><span class="kt">Node</span> <span class="kr">_</span> <span class="n">left</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">minElem</span> <span class="n">left</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&rsquo;s try this out in ghci.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">minElem</span> <span class="n">newtree</span>
</span><span class='line'><span class="kt">Just</span> <span class="mi">4</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">maxElem</span> <span class="n">newtree</span>
</span><span class='line'><span class="kt">Just</span> <span class="mi">85</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s it for now, In this post we have implemented a simple binary tree supporting basic operations except delete for which I am planing
to write a separate post. Haskell language is very concise, and because of pattern matching and good support for writing recursive functions
, most of the recursive algorithms on binary tree are translated directly into Haskell without much effort.</p>

<p>The code for binary search tree is available on <a href="https://github.com/tushargosavi/haskell-learn/blob/master/btree.hs">Github</a></p>
]]></content>
  </entry>
  
</feed>
